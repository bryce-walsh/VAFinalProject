<!DOCTYPE html>
<meta charset="utf-8">
<style>

@import url(https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Josefin+Slab|Arvo|Lato|Vollkorn|Abril+Fatface|Old+Standard+TT|Droid+Sans|Lobster|Inconsolata|Montserrat|Playfair+Display|Karla|Alegreya|Libre+Baskerville|Merriweather|Lora|Archivo+Narrow|Neuton|Signika|Questrial|Fjalla+One|Bitter|Varela+Round);

.background {
  fill: #eee;
  pointer-events: all;
}

.map-layer {
  fill: #fff;
  stroke: #aaa;
}

.effect-layer{
  pointer-events:none;
}

text{
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-weight: 300;
}

text.big-text{
  font-size: 30px;
  font-weight: 400;
}

.effect-layer text, text.dummy-text{
  font-size: 12px;
}

</style>
<body>

<div class="slidecontainer">
  <input type="range" min="0" max="719" value="0" class="slider" id="myRange">
    <p>Value: <span id="demo"></span></p>
</div>

<form>
  <input type="checkbox"  onclick="changeUncertainty()"> Uncertainty <br>
</form>
<div id="scatter_graph"></div>

<svg></svg>

<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://unpkg.com/mathjs@6.2.5/dist/math.min.js"></script>

<script>

var slider = document.getElementById("myRange");
var output = document.getElementById("demo");
output.innerHTML = slider.value; // Display the default slider value

// Update the current slider value (each time you drag the slider handle)
slider.oninput = function() {
  output.innerHTML = this.value;
  time = this.value
  updateData(this.value)
}

var width = 960,
    height = 500,
    centered;

// Define color scale
var color = d3.scale.linear()
  .clamp(true)
  .range(['#00ff00', '#ff0000']);

var projection = d3.geo.mercator()
  .scale(100000)
  // Center the Map in Colombia
  .center([-119.85, .1])
  .translate([width / 2, height / 2]);

var path = d3.geo.path()
  .projection(projection);

// Set svg width & height
var svg = d3.select('svg')
  .attr('width', width)
  .attr('height', height);

// Add background
svg.append('rect')
  .attr('class', 'background')
  .attr('width', width)
  .attr('height', height)
  .on('click', clicked);

var g = svg.append('g');

var effectLayer = g.append('g')
  .classed('effect-layer', true);

var mapLayer = g.append('g')
  .classed('map-layer', true);

var dummyText = g.append('text')
  .classed('dummy-text', true)
  .attr('x', 10)
  .attr('y', 30)
  .style('opacity', 0);

var bigText = g.append('text')
  .classed('big-text', true)
  .attr('x', 20)
  .attr('y', 45);

var globalData = {}
var globalUncertainty = {}

var time = 0

var uncertainty = false

var maxUncertainty = 0

initData()

function initData() {
  d3.json("radiation.json", function(d) {
      d3.json("uncertainty.json", function(u) {
        var entireUncertaintyData = JSON.parse(u);
        var entireData = JSON.parse(d);
        drawMap(entireData, entireUncertaintyData);
      });
  });
}

function rawValuesFromData(entireData, mapData) {
  rawValues = []
  var features = mapData.features;
  for (i = 0; i < entireData.length; i++){
    dataForTimestamp = entireData[i]
    for (j = 0; j < features.length; j++) {
      if (dataForTimestamp[nameFn(features[j])] != null){
        rawValues.push(dataForTimestamp[nameFn(features[j])])
      }
    }
  }
  return rawValues
}

function drawMap(entireData, entireUncertaintyData) {
  data = entireData[time]
  uncertaintyData = entireUncertaintyData[time]
  globalData = data
  globalUncertainty = uncertaintyData
  var geoJson = d3.json('StHimarkGeo.json', function(error, mapData) {

    var features = mapData.features;

    maxVal = 0;
    rawValues = rawValuesFromData(entireData, mapData)
    stdDev = math.std(rawValues)
    median = math.median(rawValues)

    maxUncertainty = d3.max(features, function(d) {
      return uncertaintyData[nameFn(d)]
    })

    // Update color scale domain based on data
    color.domain([0, median + .1 * stdDev]);

    // Draw each province as a path
    mapLayer.selectAll('path')
        .data(features)
      .enter().append('path')
        .attr('d', path)
        .attr('vector-effect', 'non-scaling-stroke')
        .style('fill', fillFn)
        .style('opacity', opacityFn)
        .on('mouseover', mouseover)
        .on('mouseout', mouseout)
        .on('click', clicked);
  });
}

//Read in radiation data and parse into a javascript object where the neighborhoods are the keys and the values are the values
//Calls drawMap after processing is complete
function updateData(time) {
  d3.json("radiation.json", function(d) {
      d3.json("uncertainty.json", function(u) {
        var uncertaintyData = JSON.parse(u)[time]
        var data = JSON.parse(d)[time];
        updateMap(data, uncertaintyData)
      });
  });
}

function updateMap(data, uncertaintyData){
  globalData = data
  globalUncertainty = uncertaintyData
  var geoJson = d3.json('StHimarkGeo.json', function(error, mapData) {
    var features = mapData.features; 

    // Draw each province as a path
  mapLayer.selectAll('path')
    .style('fill', function(d){return centered && d===centered ? '#D5708B' : fillFn(d);})
    .style('opacity', function(d){return opacityFn(d)});
  });
}

function changeUncertainty(){
  uncertainty = !uncertainty
  updateData(time)
}

// Get province name
function nameFn(d){
  return d && d.properties ? d.properties.Nbrhood : null;
}

// Get province color
function fillFn(d){
  return color(globalData[nameFn(d)]);
}

function opacityFn(d){
  if (uncertainty) {
    return 1 - globalUncertainty[nameFn(d)] / maxUncertainty + .01
  }
  return 1
}

// When clicked, zoom in
function clicked(d) {
  var x, y, k;

  // Compute centroid of the selected path
  if (d && centered !== d) {
    var centroid = path.centroid(d);
    x = centroid[0];
    y = centroid[1];
    k = 4;
    centered = d;
  } else {
    x = width / 2;
    y = height / 2;
    k = 1;
    centered = null;
  }

  // Highlight the clicked province
  mapLayer.selectAll('path')
    .style('fill', function(d){return centered && d===centered ? '#D5708B' : fillFn(d);});

  // Zoom
  g.transition()
    .duration(750)
    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')scale(' + k + ')translate(' + -x + ',' + -y + ')');
}

function mouseover(d){
  // Highlight hovered province
  d3.select(this).style('fill', 'orange');

  // Draw effects
  textArt(nameFn(d));
}

function mouseout(d){
  // Reset province color
  mapLayer.selectAll('path')
    .style('fill', function(d){return centered && d===centered ? '#D5708B' : fillFn(d);});

  // Remove effect text
  effectLayer.selectAll('text').transition()
    .style('opacity', 0)
    .remove();

  // Clear province name
  bigText.text('');
}

// Gimmick
// Just me playing around.
// You won't need this for a regular map.

var BASE_FONT = "'Helvetica Neue', Helvetica, Arial, sans-serif";

var FONTS = [
  "Open Sans",
  "Josefin Slab",
  "Arvo",
  "Lato",
  "Vollkorn",
  "Abril Fatface",
  "Old StandardTT",
  "Droid+Sans",
  "Lobster",
  "Inconsolata",
  "Montserrat",
  "Playfair Display",
  "Karla",
  "Alegreya",
  "Libre Baskerville",
  "Merriweather",
  "Lora",
  "Archivo Narrow",
  "Neuton",
  "Signika",
  "Questrial",
  "Fjalla One",
  "Bitter",
  "Varela Round"
];

function textArt(text){
  // Use random font
  var fontIndex = Math.round(Math.random() * FONTS.length);
  var fontFamily = FONTS[fontIndex] + ', ' + BASE_FONT;

  bigText
    .style('font-family', fontFamily)
    .text(text);

  // Use dummy text to compute actual width of the text
  // getBBox() will return bounding box
  dummyText
    .style('font-family', fontFamily)
    .text(text);
  var bbox = dummyText.node().getBBox();

  var textWidth = bbox.width;
  var textHeight = bbox.height;
  var xGap = 3;
  var yGap = 1;

  // Generate the positions of the text in the background
  var xPtr = 0;
  var yPtr = 0;
  var positions = [];
  var rowCount = 0;
  while(yPtr < height){
    while(xPtr < width){
      var point = {
        text: text,
        index: positions.length,
        x: xPtr,
        y: yPtr
      };
      var dx = point.x - width/2 + textWidth/2;
      var dy = point.y - height/2;
      point.distance = dx*dx + dy*dy;

      positions.push(point);
      xPtr += textWidth + xGap;
    }
    rowCount++;
    xPtr = rowCount%2===0 ? 0 : -textWidth/2;
    xPtr += Math.random() * 10;
    yPtr += textHeight + yGap;
  }

  var selection = effectLayer.selectAll('text')
    .data(positions, function(d){return d.text+'/'+d.index;});

  // Clear old ones
  selection.exit().transition()
    .style('opacity', 0)
    .remove();

  // Create text but set opacity to 0
  selection.enter().append('text')
    .text(function(d){return d.text;})
    .attr('x', function(d){return d.x;})
    .attr('y', function(d){return d.y;})
    .style('font-family', fontFamily)
    .style('fill', '#777')
    .style('opacity', 0);

  selection
    .style('font-family', fontFamily)
    .attr('x', function(d){return d.x;})
    .attr('y', function(d){return d.y;});

  // Create transtion to increase opacity from 0 to 0.1-0.5
  // Add delay based on distance from the center of the <svg> and a bit more randomness.
  selection.transition()
    .delay(function(d){
      return d.distance * 0.01 + Math.random()*1000;
    })
    .style('opacity', function(d){
      return 0.1 + Math.random()*0.4;
    });
}

</script>


<script>
  var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var x = d3.scale.linear()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var z = d3.scale.category10();

var svg = d3.select("#scatter_graph").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.csv("testscatter.csv", function(error, data) {
  if (error) throw error;

  // Compute the series names ("y1", "y2", etc.) from the loaded CSV.
  var seriesNames = d3.keys(data[0])
      .filter(function(d) { return d !== "x"; })
      .sort();

  // Map the data to an array of arrays of {x, y} tuples.
  var series = seriesNames.map(function(series) {
    return data.map(function(d) {
      return {x: +d.x, y: +d[series]};
    });
  });

  // Compute the scales’ domains.
  x.domain(d3.extent(d3.merge(series), function(d) { return d.x; })).nice();
  y.domain(d3.extent(d3.merge(series), function(d) { return d.y; })).nice();

  // Add the x-axis.
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.svg.axis().scale(x).orient("bottom"));

  // Add the y-axis.
  svg.append("g")
      .attr("class", "y axis")
      .call(d3.svg.axis().scale(y).orient("left"));

  // Add the points!
  svg.selectAll(".series")
      .data(series)
    .enter().append("g")
      .attr("class", "series")
      .style("fill", function(d, i) { return z(i); })
    .selectAll(".point")
      .data(function(d) { return d; })
    .enter().append("circle")
      .attr("class", "point")
      .attr("r", 4.5)
      .attr("cx", function(d) { return x(d.x); })
      .attr("cy", function(d) { return y(d.y); });
});
</script>